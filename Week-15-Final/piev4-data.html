<!-- Code from https://d3-graph-gallery.com/graph/pie_annotation.html -->
<!DOCTYPE html>
<head>
  <meta charset="utf-8">
<!-- Load d3.js -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<title>Legendary pie chart</title>
<style>
    body{
    background-color: #8f8f8f;
    }
</style>
</head>

<body>
  <!-- Create a div where the graph will take place -->
  <h1>How many legendary pokemon are there in generations 1-3, including variants?</h1>
  <div id="container"></div>
  <br>
  <h2>What is the best legendary Pokemon of the first 3 generations?</h2>
  <div id="#container-two"></div>
  
  <!-- Color scale -->
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  
  
  <script>

    // Create dummy data
    //var data = { TRUE: 31, FALSE: 413 }
    Promise.all([
      d3.csv('leg_true_false.csv'),
      d3.csv('pokemon_leg_myth.csv')
    ]).then(function(files){
      const data = {
        "pie": files[0].map(d => { return { "isLegendary": d.isLegendary, "Amount": +d.Amount } }),
        "bar": files[1].map(d => { return { "name": d.name, "type1": d.type1, "type2": d.type2, "total": +d.total, "hp": +d.hp, "attack": +d.attack, "defense": +d.defense, "sp_attack": +d.sp_attack, "sp_defense": +d.sp_defense, "speed": +d.speed, "generation": +d.generation, "mythical": d.mythical, "variant": d.variant } }) 
      }; //will refer to dataset 1 as data.pie & dataset 2 as data.bar
      console.log("2 datasets", data);

      //DECLARE CONSTANTS & ORDINAL COLOR SCALE
      const width = 600;
      const height = 600;
      const margin = { top: 10, right: 30, bottom: 40, left: 120 }
      const myColor = d3.scaleOrdinal(["#e0efee", "#df2c2b"]);

      //RADIUS INFORMATION
      //const outerRadius = width / 2;
      const outerRadius = 200;
      const innerRadius = 5;
      //const innerRadius = 150; //to make a doughnut!


      //TO CREATE A PIE, USE D3.ARC() & PIE GENERATOR

      //D3.ARC()
      //d3.arc() CREATES WEDGES 
      const arc = d3.arc()
        .innerRadius(innerRadius)//required 
        .outerRadius(outerRadius) //required
        .cornerRadius(9); //makes it more interesting looking

      //PIE GENERATOR
      //EDIT THE padAngle, startAngle & endAngle TO MAKE A MORE INTERESTING LOOKING CHART
      const pie = d3.pie().value(d => d.Amount)
        .padAngle(.38) //adds space b/w arcs - apply here so you don't add bias
        .startAngle(2.2 * Math.PI) //have to compute radians - changes shape [1 radian = (180/pi), 2pi = 90]
        .endAngle(0.35 * Math.PI); //must include start/end angle
      //.startAngle(0 * Math.PI)
      //.endAngle(1 * Math.PI);
      //.startAngle(0 * Math.PI)
      //.endAngle(0.5 * Math.PI);
      //.startAngle(0.5 * Math.PI)
      //.endAngle(2 * Math.PI);
      //.startAngle(-0.5 * Math.PI)
      //.endAngle(0 * Math.PI);

      //SVG
      const svg = d3.select("#container")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      //GROUPS TO BUILD CHART
      const groups = svg.selectAll("g.arc")
        .data(pie(data.pie))//give data to our pie generator - could also have created a separate constant instead
        .enter()
        .append("g")
        .attr("class", "arc")
        .attr("transform", "translate(" + outerRadius + "," + outerRadius + ")");//arcs transform translate 
      console.log("pie data", pie(data.pie));

      groups.append("path")
        .attr("fill", (d, i) => myColor(i)) //gave it the index (i)
        .attr("d", arc); //d of our path 

      //LABELS
      groups.append("text")
        .attr("transform", d => "translate(" + arc.centroid(d) + ")") //arc.centroid figures out the math
        .attr("text-anchor", "middle")
        .attr("class", "labels")
        .attr("stroke", "black")
        .text(d => d.data.Amount);//in console look at "pie data" to see structure (data > amount

      /*Note: if you happen to like round / doughnut charts
        another option is to think into how you might make a radial
        bar chart, another common round chart.*/



        //SECOND CHART - LOLLIPOP
        const svgTwo = d3.select("#container-two")
        .append("svg")
        .attr("width", width - 200)
        .attr("height", height + 400)
        .append('g')
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // SORT DATA - ALWAYS SORT WHEN DOING LOLLIPOPS - EASIER TO INTERPRET
        data.bar.sort((b, a) => a.total - b.total);

      // ADD X-AXIS & APPEND
      var x = d3.scaleLinear()
        .domain([0, 900])
        .range([0, width]);
      svgTwo.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x))
        .selectAll("text")
        .attr("transform", "translate(-10,0)rotate(-45)") //rotates tick labels
        .style("text-anchor", "end");

      // ADD Y-AXIS & APPEND
      var y = d3.scaleBand()
        .range([0, height])
        .domain(data.map(d => d.data.bar.name))
        .padding(1);
      svgTwo.append("g")
        .call(d3.axisLeft(y))

      // LINES
      svgTwo.selectAll("myline")
        .data(data.bar)
        .enter()
        .append("line")
        .attr("x1", x(0))
        .attr("x2", x(0))
        .attr("y1", d => y(d.data.bar.name))
        .attr("y2", d => y(d.name))
        .attr("padding", 120)
        .attr("stroke", "#718a9b")

      // CIRCLES -> START AT X=0
      svgTwo.selectAll("mycircle")
        .data(data.bar)
        .enter()
        .append("circle")
        .attr("cx", x(0))
        .attr("cy", d => y(d.name))
        .attr("r", "4")
        .style("fill", "#ee1515")
        .attr("stroke", "#222224")

      // CHANGE X-COORDINATES OF LINE & CIRCLE 
      svgTwo.selectAll("circle")
        .transition()
        .duration(4000)
        .attr("cx", d => x(d.total))

      svgTwo.selectAll("line")
        .transition()
        .duration(4000)
        .attr("x1", d => x(d.total))

    });



    
    
    
    
    // Promise.all([
    //     d3.csv('leg_true_false.csv'),
    //     d3.csv('pokemon_leg_myth.csv', d3.autoType),
    // ]).then(([data, legendary]) => {
    //       console.log('data', data)
    //       console.log('legendary', legendary)

    //       //FORMAT THE DATA
    //       data.forEach(d => {
    //         d.isLegendary = d.isLegendary;
    //         d.Amount = +d.Amount;
    //       });

    //       legendary.forEach(d => {
    //         d.name = d.name;
    //         d.type1 = d.type1;
    //         d.type2 = d.type2;
    //         d.total = +d.total;
    //         d.hp = +d.hp;
    //         d.attack = +d.attack;
    //         d.defense = +d.defense;
    //         d.sp_attack = +d.sp_attack;
    //         d.sp_defense = +d.sp_defense;
    //         d.speed = +d.speed;
    //         d.generation = +d.generation;
    //       });

          


   
    


  </script>
</body>
</html>

